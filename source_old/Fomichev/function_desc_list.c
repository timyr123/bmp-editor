/* Получения кода пиксела в зависимости от глубины цвета */
/* color - указатель на пиксел */
/* bytespp - глубина цвета в байтах (1, 2, 3, 4) */
uint32_t get_color(const void *color, int bytespp)
{
 /* Рассчитанный код цвета */
 uint32_t c;

 /* Для глубины 1, 2 и 4 просто считывается код по указателю нужного типа */
 switch ( bytespp )
 {
  case 1:
   c = *(uint8_t *)color;
   break;
  case 2:
   c = *(uint16_t *)color;
   break;
  case 4:
   c = *(uint32_t *)color;
   break;

  /* Для глубины 3 вычитывается сначала старший байт, сдвигается на 16 влево,
   затем объединяется со старшими 16 битами */
  case 3:
  default:
   c = *(((uint8_t *)color + 2));
   c <<= 16;
   c |= *(uint16_t *)color;
   break;
 }

 /* Возвращается код цвета */
 return c;
}

/* Вспомогательная функция сортировки для сравнения двух кодов цветов */
/* col1, col2 - указатели на два сравнимаемых цвета */
/* bytespp - глубина цвета в байтах (1, 2, 3, 4) */
int compar(const void *col1, const void *col2, void *bytespp)
{
 /* Определение кодов цветов */
 uint32_t a = get_color(col1, *(int *)bytespp);
 uint32_t b = get_color(col2, *(int *)bytespp);

 /* Возврат результатов сравнения кодов */
 if ( a < b )
  return -1;
 if ( a > b )
  return 1;
 return 0;
}

/* Функция вывода кода цвета и его площади */
/* color - код цвета */
/* bytespp - глубина цвета в байтах (1, 2, 3, 4) */
/* rate — коеффициент площади (площадь одного пиксела) */
void print_color(uint32_t color, int bytespp, double rate)
{
 /* Выводится код цвета с выравниваем до нужной ширины (в зависимости от глубины) */
 printf((bytespp > 2 ? (bytespp > 3 ? "%08X: %f\n" : "%06X: %f\n") : (bytespp > 0 ? "%04X: %f\n" : "%02X: %f\n")), color, rate);
}

/* Функция вывода кодов цвете и их площади */
/* img - указатель на область памяти с изображением (массив пикселов) */
/* img_size - размер области памяти с изображением в байтах */
/* bytespp - глубина цвета в байтах (1, 2, 3, 4) */
/* rate — коеффициент площади (площадь одного пиксела) */
void print(uint8_t *img, size_t img_size, int bytespp, double rate)
{
 int c = 1;   /* Количество одинаковых пикселов подряд (считаем, что минимум 1) */
 uint32_t curr;  /* Код цвета текущего пиксела */
 uint32_t next;  /* Код цвета следующего пиксела */

 /* Определение код текущего пиксела (первого) */
 curr = get_color(img, bytespp);
 /* Цикл по всему изображению (по каждому пикселу) */
 for ( size_t i = 0; i < img_size; i += bytespp )
 {
  /* Если это не последний пиксел, то определяем код цвета следующего */
  if ( i + bytespp <= img_size )
   next = get_color(img + i + bytespp, bytespp);
  /* Если пиксел последний, то записываем в следующий отличный код (для вывода на экран) */
  else
   next = curr + 1;

  /* Если коды текущего и следующего пикселей различны */
  if ( next != curr )
  {
   /* Вывод кода пиксела и площади */
   print_color(curr, bytespp, (double)c * rate);
   /* Запись кода следующего пиксела в текущий */
   curr = next;
   /* Сброс количества одинаковых пикселов (будет равен 1 после строки c++) */
   c = 0;
  }
